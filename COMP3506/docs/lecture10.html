<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1,user-scalable=no">
<meta name="description" content="undefined - microjam page">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js/styles/vs.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/goessner/mdmath/themes/publication/style.css">

<title>undefined</title>
</head>
<body id="top">
<header>






</header>
<main>
<h1 dir="auto" id="lecture-10">Lecture 10</h1>
<h2 dir="auto" id="strings-and-pattern-matching">Strings and pattern matching</h2>
<h3 dir="auto" id="strings">Strings</h3>
<ul dir="auto">
<li dir="auto">
<p dir="auto">Sequence of characters</p>
</li>
<li dir="auto">
<p dir="auto">Alhpabet <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span> - set of possible characters for a family of strings</p>
<ul dir="auto">
<li dir="auto">{0,1} (binary alphabet)</li>
<li dir="auto">{A, C, G, T} (DNA structures)</li>
</ul>
</li>
<li dir="auto">
<p dir="auto">Substring <code>S[i,...j]</code></p>
</li>
<li dir="auto">
<p dir="auto">Prefix: substring of the type <code>S[0..i]</code></p>
</li>
<li dir="auto">
<p dir="auto">Suffix: substring of the type <code>S[i...m-1]</code></p>
</li>
</ul>
<h3 dir="auto" id="pattern-matching-problem">Pattern Matching Problem</h3>
<ul dir="auto">
<li dir="auto">Given string <code>T</code> (text) and P(pattern)
<ul dir="auto">
<li dir="auto">Find substring of <code>T</code> equal to <code>P</code></li>
</ul>
</li>
</ul>
<h3 dir="auto" id="brute-force-pattern-matching">Brute force pattern matching</h3>
<ul dir="auto">
<li dir="auto">Compare the pattern P with the text T
for each possible shift of P relative to T</li>
</ul>
<pre><code dir="auto"><code><div>Algorithm BruteForceMatch(T, P)
    Input: text T of size n and pattern P of size m
    Output: starting index of a substring of T equal to P 
        or -1 if no such substring exists 

    for  i &lt;- 0 to n – m  do
    { test shift i of the pattern }
        j &lt;- 0
        while  j &lt; m OR T[i + j] = P[j]  do
            j &lt;- j + 1
        if  j = m  then
            return  i {match at i}
        else
            break while loop {mismatch}
        return  -1 {no match anywhere}

</div></code></code></pre>
<ul dir="auto">
<li dir="auto">Brute-force pattern matching runs in time O(nm)</li>
<li dir="auto">Example of worst case:
<ul dir="auto">
<li dir="auto">T = aaa … ah and P = aaah</li>
</ul>
</li>
</ul>
<p dir="auto"><img src="image-1.png" alt="Alt text" data-src="image-1.png"></p>
<h3 dir="auto" id="can-we-do-better">Can we do better?</h3>
<ul dir="auto">
<li dir="auto">Boyer-Moore pattern matching algorithm</li>
<li dir="auto">Attempts to improve the Brute-Force
approach by using two heuristics
<ul dir="auto">
<li dir="auto">Looking-glass heuristic</li>
<li dir="auto">Character-jump heuristic</li>
</ul>
</li>
</ul>
<h3 dir="auto" id="boyer-moore-looking-glass-heuristic">Boyer-Moore: Looking-Glass Heuristic</h3>
<ul dir="auto">
<li dir="auto">Compare P with a subsequence of T moving
backwards</li>
</ul>
<p dir="auto"><img src="image-3.png" alt="Alt text" data-src="image-3.png"></p>
<h3 dir="auto" id="boyer-moore-character-jump-heuristic">Boyer-Moore: Character-Jump Heuristic</h3>
<ul dir="auto">
<li dir="auto">
<p dir="auto">When a mismatch occurs at T[i] = c</p>
<ul dir="auto">
<li dir="auto">if P contains c, shift P to align the last occurrence of c in
P with T[i]
<img src="image-4.png" alt="Alt text" data-src="image-4.png"></li>
</ul>
</li>
<li dir="auto">
<p dir="auto">Else, shift P to align P[0] with T[i + 1]</p>
</li>
</ul>
<p dir="auto"><img src="image-5.png" alt="Alt text" data-src="image-5.png"></p>
<h3 dir="auto" id="example">Example</h3>
<ul dir="auto">
<li dir="auto">at the end, mitmatches on a h and realigns
<img src="image-6.png" alt="Alt text" data-src="image-6.png"></li>
</ul>
<h3 dir="auto" id="last-occurrence-function">Last-Occurrence Function</h3>
<ul dir="auto">
<li dir="auto">
<p dir="auto">Boyer-Moore’s algorithm preprocesses the
pattern P and the alphabet <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span> to build the last-occurrence function L mapping <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span> to integers, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span> is defined as</p>
<ul dir="auto">
<li dir="auto">largest index i such that P[i] = c or</li>
<li dir="auto">-1 if no such index exists</li>
</ul>
</li>
<li dir="auto">
<p dir="auto">Example</p>
<ul dir="auto">
<li dir="auto"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi></mrow></mrow><annotation encoding="application/x-tex">\Sigma = {a, b, c, d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span></span></span></span></span></li>
<li dir="auto"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mi>a</mi><mi>b</mi><mi>a</mi><mi>c</mi><mi>a</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">P = abacab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">aba</span><span class="mord mathnormal">c</span><span class="mord mathnormal">ab</span></span></span></span></li>
</ul>
</li>
</ul>
<p dir="auto"><img src="image-7.png" alt="Alt text" data-src="image-7.png"></p>
<h3 dir="auto" id="last-occurrence-function-1">Last Occurrence Function</h3>
<p dir="auto">Can be represented by an array indexed by the numeric codes of the characters</p>
<ul dir="auto">
<li dir="auto">computed in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> time, where m is the
size of P and s is the size of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span></li>
<li dir="auto">accessed in O(1) time</li>
</ul>
<pre><code dir="auto"><code><div>Algorithm BoyerMooreMatch(T, P, S)
L &lt;- lastOccurenceFunction(P, S)
i &lt;- m - 1   { m is size of P }
j &lt;- m - 1

repeat 
    if T[i] = P[j] then
        if  j = 0 then
            return  i { match at i }
        else
            i &lt;- i - 1
            j &lt;- j - 1
    else
        { character-jump }
        l &lt;- L[T[i]]
        i &lt;- i + m – min(j, 1 + l)
        j &lt;- m - 1
    until  i &gt; n - 1
    return -1 { no match}
</div></code></code></pre>
<h3 dir="auto" id="performance-analysis">Performance analysis</h3>
<ul dir="auto">
<li dir="auto">Runs in O(nm + s) time
<ul dir="auto">
<li dir="auto">Could potentially be worst than brute force time</li>
</ul>
</li>
<li dir="auto">Example of worst case
<ul dir="auto">
<li dir="auto">T = aaa … a</li>
<li dir="auto">P = baaa</li>
</ul>
</li>
<li dir="auto">Boyer-Moore’s algorithm
is significantly faster than
the brute-force algorithm</li>
</ul>
<h4 dir="auto" id="worst-case-example">Worst case example</h4>
<p dir="auto"><img src="image-8.png" alt="Alt text" data-src="image-8.png"></p>
<h3 dir="auto" id="knuth-morris-pratt-kmp-algorithm">Knuth-Morris-Pratt (KMP) Algorithm</h3>
<ul dir="auto">
<li dir="auto">Compares the pattern to the text left-to-right
<ul dir="auto">
<li dir="auto">but shifts the pattern more intelligently than the brute-force algorithm</li>
</ul>
</li>
<li dir="auto">When a mismatch occurs, what is the most we can shift the pattern so as to avoid redundant comparisons?</li>
<li dir="auto">Answer: the largest prefix of <code>P[0...j-1]</code> that is a suffix of <code>P[1...j-1]</code>
<ul dir="auto">
<li dir="auto">repeat redundant patterns</li>
<li dir="auto">computes a failure function</li>
</ul>
</li>
</ul>
<p dir="auto"><img src="image-9.png" alt="Alt text" data-src="image-9.png"></p>
<h3 dir="auto" id="kmp-failure-function">KMP failure function</h3>
<ul dir="auto">
<li dir="auto">KMP algorithm preprocesses the pattern</li>
<li dir="auto">Failure function F(j) is defined as the size of the largest prefix of P[0..j] that is also a suffix of P[1..j]</li>
<li dir="auto">KMP algorithm modifies the brute-force algorithm so that if a mismatch occurs at P[j] <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\ne</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> T[i]  we set j &lt;- F(j - 1)</li>
</ul>
<table dir="auto">
<thead dir="auto">
<tr dir="auto">
<th><code>J</code></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody dir="auto">
<tr dir="auto">
<td><code>P[j]</code></td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>a</td>
<td>b</td>
<td>a</td>
</tr>
<tr dir="auto">
<td><code>F(j)</code></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
<h3 dir="auto" id="kmp-algorithm">KMP Algorithm</h3>
<ul dir="auto">
<li dir="auto">Failure function can be represented by an array and can be computed in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> time</li>
<li dir="auto">Each iteration of the while-loop, either
<ul dir="auto">
<li dir="auto">i increases by one, or</li>
<li dir="auto">shift amount i - j increases by at least one (observe that F(j - 1) &lt; j)</li>
</ul>
</li>
<li dir="auto">Hence, there are no more than 2n iterations of the while-loop</li>
<li dir="auto">Thus, KMP’s algorithm runs in optimal time <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
<pre><code dir="auto"><code><div>Algorithm KMPMatch(T, P)
F &lt;- failureFunction(P)
i &lt;- 0
j &lt;- 0
while  i &lt; length(T)
    if  T[i] = P[j]  then
        if  j = length(P) - 1  then
            return  i - j { match }
        else
            i &lt;- i + 1
            j &lt;- j + 1
else
    if  j &gt; 0 then
        j &lt;- F[j - 1]
    else
        i &lt;- i + 1
return  -1 { no match }
</div></code></code></pre>
<h3 dir="auto" id="example-1">Example</h3>
<p dir="auto"><img src="image-10.png" alt="Alt text" data-src="image-10.png"></p>
<h2 dir="auto" id="tries---retrieval-tries">Tries - Retrieval Tries</h2>
<h3 dir="auto" id="preprocessing-steps">Preprocessing steps</h3>
<ul dir="auto">
<li dir="auto">Preprocessing the pattern speeds up pattern matching queries
<ul dir="auto">
<li dir="auto">After preprocessing the pattern, KMP’s algorithm performs pattern matching in time proportional to the text size</li>
</ul>
</li>
<li dir="auto">If text is large, and searched often, preprocess the text (<strong>create and index</strong>)
<ul dir="auto">
<li dir="auto">trie supports pattern matching queries in time proportional to the pattern size</li>
</ul>
</li>
</ul>
<p dir="auto">Standard trie for the set of strings
S = { bear, bell, bid, bull, buy, sell, stock, stop }</p>
<p dir="auto"><img src="image-11.png" alt="Alt text" data-src="image-11.png"></p>
<ul dir="auto">
<li dir="auto">sometime represented as a special symbol to denote that a word ends on an internal node</li>
</ul>
<p dir="auto"><img src="image-12.png" alt="Alt text" data-src="image-12.png"></p>
<h3 dir="auto" id="analysis-of-standard-tries">Analysis of standard tries</h3>
<ul dir="auto">
<li dir="auto">
<p dir="auto"><code>n</code> total size of the strings in S</p>
</li>
<li dir="auto">
<p dir="auto"><code>m</code> size of the string parameter of the (e.g. search) operation</p>
</li>
<li dir="auto">
<p dir="auto"><code>d</code> size of the alphabet (mostly fixed? i.e. acgt)</p>
</li>
<li dir="auto">
<p dir="auto">uses O(n) space</p>
</li>
<li dir="auto">
<p dir="auto">supports searches, insertions and deletions in time O(dm)</p>
</li>
<li dir="auto">
<p dir="auto">Insert words of the text into trie</p>
</li>
<li dir="auto">
<p dir="auto">Each leaf is associated w/ one particular word</p>
</li>
<li dir="auto">
<p dir="auto">Leaf stores indices where associated word begins (“see” starts at index 0 &amp; 24, leaf for “see” stores those indices)</p>
</li>
</ul>
<p dir="auto"><img src="image-13.png" alt="Alt text" data-src="image-13.png"></p>
<p dir="auto"><img src="image-14.png" alt="Alt text" data-src="image-14.png"></p>
<h3 dir="auto" id="compressed-tries">Compressed Tries</h3>
<ul dir="auto">
<li dir="auto">
<p dir="auto">Compressed trie has internal nodes of degree at least two</p>
</li>
<li dir="auto">
<p dir="auto">Obtained from standard trie by compressing chains of redundant nodes</p>
</li>
<li dir="auto">
<p dir="auto">“i” and “d” in “bid” are redundant</p>
<ul dir="auto">
<li dir="auto">they signify the same word</li>
</ul>
</li>
</ul>
<p dir="auto"><img src="image-15.png" alt="Alt text" data-src="image-15.png"></p>
<ul dir="auto">
<li dir="auto">What is the maximum number of nodes in a compressed trie storing s words?
<ul dir="auto">
<li dir="auto">s + (s -1) = 2 s -1</li>
</ul>
</li>
</ul>
<h3 dir="auto" id="compact-representation">Compact Representation</h3>
<p dir="auto">Want to create a compact representation of a compressed tree</p>
<p dir="auto">Compact representation of a compressed trie for an array of strings</p>
<ul dir="auto">
<li dir="auto">Stores ranges of indices instead of substrings at the nodes</li>
<li dir="auto">Uses <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span></span></span></span> space, where s is the number of strings in the array</li>
<li dir="auto">Serves as an auxiliary index structure</li>
</ul>
<h3 dir="auto" id="tries---outside-of-patterns">Tries - outside of patterns</h3>
<ul dir="auto">
<li dir="auto">Tries have other common uses outside of simple pattern matching (finding patterns in a given text efficiently)</li>
<li dir="auto">One common example: Autosuggestion engines</li>
</ul>
<h3 dir="auto" id="input-query-logs">Input: Query Logs</h3>
<ul dir="auto">
<li dir="auto">Take a large log of historical queries</li>
<li dir="auto">Count the number of times each query appears</li>
<li dir="auto">Basic idea: The autosuggestion engine should spit out suggestions based on historical popularity</li>
<li dir="auto">Input data then becomes a sequence of <query> <count> pairs</li>
</ul>
<h3 dir="auto" id="building-the-trie">Building the Trie</h3>
<ul dir="auto">
<li dir="auto">Each node (or edge) also holds a weight corresponding to the volume of queries that were issued for that prefix</li>
</ul>

</main>
</body>
</html>