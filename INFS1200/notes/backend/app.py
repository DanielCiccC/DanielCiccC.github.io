from dotenv import load_dotenv

# This needs to happen before any imports
load_dotenv()

from functools import wraps, singledispatch
from typing import Callable, Any
from http import HTTPStatus
from typing import Literal
from flask_cors import CORS

import logging
from logging.config import dictConfig

from flask import Flask, Response, make_response
import sqlalchemy as sa

from engine import engine
from context import Context

from auth import valid_jwt

dictConfig(
    {
        "version": 1,
        "formatters": {
            "default": {
                "format": "[%(asctime)s] %(levelname)s in %(module)s: %(message)s",
            }
        },
        "handlers": {
            "wsgi": {
                "class": "logging.StreamHandler",
                "stream": "ext://flask.logging.wsgi_errors_stream",
                "formatter": "default",
            }
        },
        # "root": {"level": "INFO", "handlers": ["wsgi"]},
        "loggers": {
            "app": {"level": "INFO", "handlers": ["wsgi"], "propagate": True},
        },
    }
)

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

_context: Context = Context(engine)


@singledispatch
def transform_handler_response(
    response: Any, response_status: HTTPStatus = HTTPStatus.OK
) -> Response:
    return make_response(response, response_status)


@transform_handler_response.register
def _(response: None, response_status: HTTPStatus = HTTPStatus.OK) -> Response:
    logging.info("Returned an empty response")
    return Response(status=HTTPStatus.NO_CONTENT)


@transform_handler_response.register
def _(response: dict, response_status: HTTPStatus = HTTPStatus.OK) -> Response:
    return make_response(response, response_status)


@transform_handler_response.register
def _(response: Response, response_status: HTTPStatus = HTTPStatus.OK) -> Response:
    return response


def attach_api(
    flask_app: Flask,
    *,
    methods: list[
        Literal["GET"]
        | Literal["POST"]
        | Literal["DELETE"]
        | Literal["PATCH"]
        | Literal["OPTIONS"]
    ],
    base_url: str,
    public: bool = False,
):
    def wrapper(api_handler: Callable[[Context], Response | dict[str, Any] | None]):
        @flask_app.route(base_url, methods=methods)
        @wraps(api_handler)
        def decorated():

            if not public and not valid_jwt():
                return Response("Not authorized", status=HTTPStatus.FORBIDDEN)

            try:
                handler_response = api_handler(_context)
            except sa.exc.MultipleResultsFound as e:
                return make_response(
                    {
                        "reason": "Multiple responses returned from query.",
                        "error": str(e),
                    },
                    HTTPStatus.INTERNAL_SERVER_ERROR,
                )
            except sa.exc.NoResultFound as e:
                return make_response(
                    {"error": str(e)},
                    HTTPStatus.NOT_FOUND,
                )
            except Exception as e:
                logger.error(e)
                # Have a catch all for any exceptions generated by the routes.
                # Will be better to break this up a created specific responses/
                # actions for different exceptions.
                return make_response(
                    {"error": str(e)}, HTTPStatus.INTERNAL_SERVER_ERROR
                )

            return transform_handler_response(handler_response)

        return decorated

    return wrapper


def create_app(test_config=None):
    # create and configure the app
    flask_app = Flask(__name__, instance_relative_config=True)
    CORS(flask_app)

    # Default config
    flask_app.config.update(
        {
            "MAX_CONTENT_LENGTH": 1024**3,  # 1GB upload limit
            "TEMPLATES_AUTO_RELOAD": True,  # Reload templates from disk if they change
            "COMPRESS_MIN_SIZE": 1000,  # (kB) Don't waste time compressing small responses
        }
    )

    # Healthcheck
    @flask_app.route("/healthcheck", methods=["POST"])
    def healthcheck():
        logger.debug("healthcheck")

        # Test the db connection
        with engine.connect() as db_connection:
            db_connection.execute(sa.text("SELECT 1"))

        return make_response("PASS", HTTPStatus.OK)

    return flask_app
